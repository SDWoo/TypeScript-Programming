# 3. 타입의 모든것

> 타입: 값과 이 값으로 할 수 있는 일의 집합

- Boolean 타입은 모든 불과 불에 수행할 수 있는 모든 연산의 집합
- number 타입은 모든 숫자과 숫자에 수행할 수 있는 모든 연산의 집합
- string 타입은 모든 문자열과 문자열에 수행할 수 있는 모든 연산의 집합

![그림3-1 타입스크립트의 타입 계층](https://gusrb3164.github.io/assets/images/posts/ts-types.jpg)

### 3.1 타입을 이야기하다.

```tsx
// 밑의 예제와 같이 받고 싶은 타입과 다른 타입이 들어오면 유효하지 않은 작업을 수행한다.

function squareOf(n) {
  return n * n;
}
squareOf(2); // 4로 평가
squareOf('z'); // NaN으로 평가

// 매개변수에 타입을 지정해주자!

function squareOf(n: number) {
  return n * n;
}

squareOf(2);
squareOf('z'); // 에러가 남
```

- 위와 코드에서 알 수 있는 점
  - squareOf의 매개변수 n은 number로 제한된다.
  - 2 값은 number에 할당할 수 있는 타입이다.

---

### 3.2 타입의 가나다

> 타입 별칭, 유니온 타입, 인터섹션 타입 등 여러가지 언어 기능 확인하기

#### 1) any

> 타입들의 대부이다.

- 뭐든지 할 수 있지만, 꼭 필요한 상황이 아니라면 사용하지 않는 것이 좋다.
- 컴파일 타임에 모두가 타입이 있어야 하므로 프로그래머와 타입스크립트 둘다 타입을 알 수 없는 경우 any로 가정한다.
- 최후의 보루로, 가급적 사용하지 않아야 한다. (자바스크립트처엄 동작하면서 타입검사기가 작동하지 않는다.)

```
💡 TSC 플래그: nolmplicitAny
=> 타입스크립트의 기본 설정은 자유를 허용하므로, any로 추론되는 값을 발견하더라도 예외를 발생시키지 않는다.
=> 암묵적인 any가 나타났을 때 예외를 일으키고 싶으면, tsconfig.json에서 noImplicitAny를 활성화 시킨다.
=> strict 패밀리에 속하므로 strict가 true라면 따로 안해줘도 된다!
```

---

#### 2) unknown

> 타입을 미리 알 수 없는 어떤 값이 있을 때 any 대신 unknown을 사용하자!

- any처럼 모든 값을 대표한다.
- 하지만, unknown의 타입을 검사해 정제하기 전까지는 사용할 수 없게 강제한다.

```tsx
let a: unknown = 30; // unknown
let b = a === 123; // boolean
let c = a + 10; // 에러 => a 객체의 타입이 unknown임
if (typeof a === 'number') {
  let d = a + 10; // number
}
```

##### unknown 사용 방법 정리

1. 타입스크립트가 무언가의 타입을 unknown이라고 추론하는 상황은 없다.
   - unknown타입을 사용하고자 한다면, 개발자가 명시적으로 설정해야 한다.
2. unknown 타입이 아닌 값과 unknown 타입인 값을 비교할 수 있다.
3. 하지만 unknown 값이 특정 타입이라고 가정하고 해당 타입에서 지원하는 동작을 수행할 수는 없다.
   - 먼저 타입스크립트에게 해당 값이 특정 타입임을 증명해야 한다.

---

#### 3) boolean

> boolean 타입은 true, false 두 개의 값을 갖는다.

- 추론 방법
  1. 어떤 값이 boolean인지 타입스크립트가 추론하게 한다.
  2. 어떤 값이 특정 boolean인지 타입스크립트가 추론하게 한다.
  3. 값이 boolean임을 명시적으로 타입스크립트에 알린다.
  4. 값이 특정 boolean임을 명시적으로 타입스크립트에 알린다.
- 실제 프로그래밍에서는 첫번째와 두번째 방식을 많이 사용하며, 세번째는 거의 사용안함.
- 네번째는 추가적인 타입 안정성을 얻을 목적으로 드물지만 사용이 된다.

```tsx
// 추론 방법 예제
let a = true; // 1번, boolean
const c = true; // 2번, true
let d: boolean = true; // 3번, boolean
let e: true = true; // 4번, true
```

##### 💡 타입 리터럴

> 오직 하나의 값을 나타내는 타입이다. (값을 타입으로 사용함)

- const로 선언한 상수의 경우 그 변수의 값이 절대 변하지 않는다.
- 따라서 해당 변수가 가질 수 있는 가장 좁은 타입으로 추론한다.
- let이나 const이나에 따라 타입스크립트가 추론하는 타입이 달라질 수 있다.

---

#### 4) number

> number타입은 모든 숫자의 집합이다.

- 숫자 관련 연산을 수행할 수 있다.
- 추론 방법
  1. 타입스크립트가 값이 number임을 추론하게 한다.
  2. const를 이용해 타입스크립트가 값이 특정 number임을 추론하게 한다.
  3. 값이 number임을 명시적으로 타입스크립트에 알린다.
  4. 타입스크립트에 값이 특정 number임을 명시적으로 알린다.

---

#### 5) bigint

> bigint는 라운딩 관련 에러 걱정 없이 큰 정수를 처리할 수 있다.

- 선언하는 방법은 위와 같이 네가지다.
- bigint는 정수(무조건)에 n을 붙여 표시한다.
- 지원하지 않는 플랫폼이 있으니 잘 사용하자!
- 생소할 수 있으니 예제를 보자

```tsx
let a = 1234n; // bigint
const b = 5678n; // 5678n
var c = a + b; // bigint
```

---

#### 6) string

> 모든 문자열의 집합으로 +, .slice등의 연산을 수행할 수 있다.

- 똑같이 네가지 방식으로 선언할 수 있다.
- 가능하다면 타입스크립트가 string을 추론하도록 두는 것이 좋다.

---

#### 7) symbol

> 객체와 맵에서 문자열 키를 대신하는 용도로 자주 사용한다.

- 심벌 키를 사용하면 사람들이 잘 알려진 키만 사용하도록 강제할 수 있으므로 키를 잘못 설정하는 실수를 방지한다.
- 심볼은 unique symbol을 만들 수 있는 방법이 있다.
  1. 새 symbol을 선언하고 const 변수에 할당하면 타입 스크립트가 unique symbol 타입으로 추론한다.
     - 코드 편집기에서는 unique symbol이 아니라 'typeof 변수명' 형태로 보여줄 것이다.
  2. const 변수의 타입을 unique symbol로 명시적으로 정의할 수 있다.
  3. unique symbol은 자신과 항상 같다.
  4. 타입스크립트는 컴파일 타임에 unique symbol이 다른 unique symbol과 같지 않을 것이라는 사실을 알 수 있다.

#### 8) 객체

> 객체 타입은 객체의 형태를 정의한다.

- 객체 타입만으로는 {}로 만든 간단한 객체와 생성자 함수와 new키워드로 만든 복잡한 객체를 구분할 수 없다.
  - 자바스크립트가 구조 기반 타입을 갖도록 설계되었기 때문
  - 타입스크립트도 자바스크립트 스타일을 선호한다.
- 구조 기반 타입화: 객체의 이름에 상관없이 객체가 어떤 프로퍼티를 갖고 있는지를 따진다. (덕 타이핑이라고도 한다.)

1. object로 선언하기 : 그다지 좋지 않은 기능이다. (프로퍼티에도 접근이 불가능하기 때문)
2. 객체 리터럴 문법으로 선언하기: 타입스크립트가 추론하는 방식이다.
   - 중괄호 안에서 명시적으로 프로퍼티의 타입을 묘사할 수 있다.

```
🤔 객체를 const로 선언할때의 추론은 어떻게 될까?
const a: {b: number} = {
    b: 12 // 여전히 {b:number}
}

- b가 12가 아닌 number로 추론된다.
- 객체를 const로 선언해도 타입스크립트는 프로퍼티를 더 좁은 타입으로 추론하지 않는다.

👊 확실한 할당
- 타입스크립트는 변수를 사용하기 전에 무조건 할당하도록 강제한다.
```

- 선택형과 예정에 없던 프로퍼티가 추가될 수 있다고 알려주기

```tsx
let a: {
  b: number; // 1
  c?: string; // 2
  [key: number]: boolean; // 3
  readonly firstItem: string; // readonly 적용 시키기
};
```

1. a는 number타입의 프로퍼티 b를 포함한다.
2. a는 string타입의 프로퍼티 c를 포함할 수도 있다.
3. a는 boolean타입의 값을 갖는 number 타입의 프로퍼티를 여러개 포함할 수 있다.

##### 인덱스 시그니처

- [key: t]: U
- 위와 같은 문법을 인덱스 시그니처라 부르며, 타입스크립트에 어떤 객체가 여러키를 가질 수 있음을 알려준다.
- 이 객체에서 모든 T 타입의 키는 U타입의 갖는다라고 해석
- 꼭 알아야할 규칙: 인덱스 시그니처의 키(T)는 반드시 number나 string에 할당될 수 있는 타입이여야 한다.

- 타입스크립트 객체 정의 방법 정리

1. 객체 리터럴 또는 형태라 불리는 표기법({a: string})
   - 객체가 어떤 필드를 포함할 수 있는지 알고 있거나 모든 값이 같은 타입을 가질 때 사용
2. 빈 객체 리터럴 표기법({}). 이방법은 사용하지 말자
3. object타입. 어떤 필드를 가지고 있는지는 관심 없고, 그저 객체가 필요할 때.
4. Obejct타입. 사용하지 않는 것이 좋다.

---

### 9) 타입별칭, 유니온, 인터섹션

#### 타입 별칭

> 변수를 선언해서 값 대신 변수로 칭하듯이 타입 별칭으로 타입을 가리킬 수 있다.

- 하나의 타입을 두번 정의할 수 없다.
- let 과 const 처럼 타입 별칭도 블록 영역에 적용된다.

```tsx
type Age = number;
type Person = {
  name: string;
  age: Age;
};
```

#### 유니온(|)과 인터섹션(&) 타입

> 합집합과 교집합의 개념과 비슷하지만 살짝 다르다.

- 유니온(|): A or B or Both
- 인터섹션(&): A and B
- 실전에서는 인터섹션보다 유니온을 자주 사용한다.

```tsx
type Returns = string | null // ex
function(a:string, b:number) {
    return a || b
}
```

---

#### 10)배열

> 타입스크립트 배열은 연결, 푸시, 검색, 슬라이스 등을 지원하는 특별한 객체다.

- 타입스크립트 배열은 T[]와 Array<T>라는 두 가지 배열 문법을 지원한다.
- 대개 배열을 동형으로 만들어 처리한다. (배열의 모든 항목이 같은 타입을 갖도록 설계하려 노력하는 것)
- 배열도 const로 선언해도 더 좁게 추론하지 않는다.
- 빈 배열로 초기화하면 any[] 일 것으로 추측한다.
  - 해당 배열은 배열이 정의된 영역으로 벗어나면 더 이상 확장할 수 없도록 최종 타입을 할당한다.

#### 11) 튜플

> 배열의 서브타입으로 길이가 고정되고, 각 인덱스의 타입이 알려진 배열의 일종이다.

- let a: [string, string, number?, ...string[]] 와 같이 선언

#### 12) null, undefined, void, never

- null, undefined 규칙에 맞게 작성하자.
- void는 명시적으로 아무것도 반환하지 않는 함수에 반환타입이다. (console)
- never는 절대 반환하지 안흔 함수 타입을 가리킨다. (에러 던지기 or 무한 루프)

### 13) 열거형 (enum)

> 해당 타입으로 사용할 수 있는 값을 열거하는 기법이다.

- 점 또는 괄호 표기법으로 열거형 값에 접근할 수 있다.
- 열거형 멤버에는 명시적으로 값을 할당하는 습관을 기르는 것이 좋다.
- 안전하지 않은 값에 접근할 수 있는 경우도 있을떈 const로 선언
- npm으로 배포하거나 라이브러리로 제겅호라 프로그램에서는 const enum을 사용하지 말아야 한다.
  - tsconfig.json에서 preserveConstEnum을 true로 바꾸면 활성화 가능
- 숫자 값을 받는 열거형은 전체 열거형의 안전성 해칠 수 있음
- 열거형 자체를 멀리하란다 다 적었는데 응으아아아아 안전하게 사용할 수 있는 방법이 까다롭기 때문!
